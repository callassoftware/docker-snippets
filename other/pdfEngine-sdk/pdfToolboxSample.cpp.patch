--- orig.pdfToolboxSample.cpp	2025-07-07 18:31:15.147618540 +0200
+++ pdfToolboxSample.cpp	2025-07-09 11:17:16.427059108 +0200
@@ -107,6 +107,39 @@
 		std::string msg_;
 };
 
+
+std::vector<const PTB_utf8_char_t*> tokenize_licenseserver_urls(const char *s) {
+	std::vector<const PTB_utf8_char_t*> tokens;
+
+	if (!s) return tokens;
+
+	// Make a copy to avoid modifying the original
+	char* tmp = strdup(s);  // allocates memory (must be freed by the caller)
+	if (!tmp) return tokens;
+
+	const char delimiter(';');
+	char* token = tmp;
+	char* pos = tmp;
+
+	while (*pos) {
+		if (*pos == delimiter) {
+			*pos = '\0';
+			tokens.push_back((const PTB_utf8_char_t*)token);
+			token = pos + 1;
+		}
+		pos++;
+    	}
+    	tokens.push_back((const PTB_utf8_char_t*)token);    // Add the last token
+
+	for (const PTB_utf8_char_t* token : tokens) {
+		std::cerr << "tokenized_licenseserver_url '" << token << "'" <<  std::endl;
+	}
+
+	return tokens;
+}
+
+
+
 ////////////////////////////////////////////////////////////////////////////////
 /*! convert a PTB_StringID to a std::string
 */
@@ -160,12 +193,29 @@
 	if( err != PTB_eerrNone ) {
 		std::ostringstream oss; 
 
+		oss << "ERROR: 0x" << std::hex << err;
+
 		if( bUseDict ) {
-			oss << "ERROR: 0x" << std::hex << err;
 			oss << " (" << getErrorString( err ) << ")" << std::endl;
-		} else { 
-			oss << "ERROR: 0x" << std::hex << err << std::endl;
 		}
+		else if (err == PTB_eerrKeyCodeFail) 
+			oss << " (" << "The keycode is incorrect" << ")";
+		else if (err == PTB_eerrKeyCodeExpire) 
+			oss << " (" << "The keycode has expired" << ")";
+		else if (err == PTB_eerrLicenseCommunication) 
+			oss << " (" << "License server communication error has been detected" << ")";
+		else if (err == PTB_eerrLicenseNoServer) 
+			oss << " (" << "No license server found" << ")";
+		else if (err == PTB_eerrLicenseNoCartridge) 
+			oss << " (" << "License server found but no matching cartridge installed" << ")";
+		else if (err == PTB_eerrLicenseNoLicense) 
+			oss << " (" << "License server with matching cartridge found, but no free license" << ")";
+		else if (err == PTB_eerrLicenseFailoverIncomplete) 
+			oss << " (" << "License server found but failover network is incomplete" << ")";
+		
+			
+		oss << std::endl;
+
 		if( bThrow )
 			throw CException( oss.str() );
 		else
@@ -285,7 +335,7 @@
 		void init( const std::string& keycode, const std::string& keycodeAddOn )
 		{
 			if( !initialized_ ) {
-				require_noErr( PTB_LibInit( keycode.c_str(), keycodeAddOn.c_str(), NULL ), true, false );
+				require_noErr( PTB_LibInit( NULL, NULL, NULL ), true, false );
 				log( "callas pdfEngine SDK initialized" );
 				initialized_ = true;
 			}
@@ -3161,15 +3211,36 @@
 		// you can also change the internal base temporary folder by specifiing PTB_eptTemp
 		// PTB_LibSetPath( PTB_eptTemp, reinterpret_cast< const PTB_Path_t* >( "<Path>" ) );
 
+		char *env_ls_urls = getenv("CALLAS_LICENSESERVER_URLS");
+		if (env_ls_urls == NULL) {
+			std::cerr << "env var CALLAS_LICENSESERVER_URLS is empty - good bye" << std::endl;
+			return EXIT_WITH_FAILURE;
+		}
+
 		CLibInit lib;
 		lib.init( args.at(1), args.at(2) );
+	
+		std::cerr << "setting up remote license server(s) ..." << std::endl;
+		std::vector<const PTB_utf8_char_t*> ls_urls = tokenize_licenseserver_urls(env_ls_urls);
+		const PTB_utf8_char_t *ls_message= (const PTB_utf8_char_t *)getenv("CALLAS_LICENSESERVER_MSG");
+		PTB_uint32_t ls_timeout(5);
+		PTB_ELicenseServerType ls_types(static_cast<PTB_ELicenseServerType> (PTB_eelstRuncount|PTB_eelstCredits));
+		require_noErr( PTB_LicenseServerSetup2( &ls_urls[0], ls_urls.size(), ls_timeout, ls_types, ls_message ), true, false);
+
+		// note: you can do some "licensing fine tuning" by using explicit PTB_LicenseServerGetLicense (and PTB_LicenseServerFreeLicense) calls. If you
+		//       dont use it, then PTB_LicenseServerSetup2 automatically surrounds each PTB_xxxxx call with an implicit call to PTB_LicenseServerGetLicense
+                //       and PTB_LicenseServerFreeLicense
+		// std::cerr << "explictly requesting a remote license ..." << std::endl;
+		// PTB_ELicenseServerType usedLicense = PTB_eelstNone;
+		// require_noErr( PTB_LicenseServerGetLicense( ls_timeout, ls_types, &usedLicense ), true, false);
+		// if (usedLicense & PTB_eelstCredits) std::cerr << "... received a credits license ..." << std::endl;	
+		// if (usedLicense & PTB_eelstRuncount) std::cerr  << "... received a runcount license ..." << std::endl;	
 
-		// to change the reporting language you can use the function PTB_LanguageSet()
-		// the languages codes can be determine by PTB_LanguageEnum() or by
-		// using the sample mode --listlanguages
-		// PTB_LanguageSet( reinterpret_cast< const PTB_sys_char_t* >( "de" ) );
 		int ret = samples( args );
 
+		// std::cerr << "releasing the remote license ..." << std::endl;
+		// PTB_LicenseServerFreeLicense();
+
 		lib.deinit();
 
 		log( "bye..." );
